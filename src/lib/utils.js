/**
 * Клонирует шаблон и собирает все элементы с атрибутом data-name
 *
 * @param {string} templateId - ID элемента шаблона, существующего в документе (не безопасно!)
 * @returns {{container: Node, elements: unknown}} - Объект, содержащий контейнер и именованные элементы
 *
 * Подробнее: Эта функция использует HTML-шаблоны (<template>) для создания
 * переиспользуемых фрагментов DOM. Функция находит шаблон по ID, клонирует его
 * и собирает все вложенные элементы, у которых есть атрибут data-name,
 * в удобный объект для дальнейшего доступа к этим элементам.
 */
export function cloneTemplate(templateId) {
  // Находим шаблон в документе по его ID
  const template = document.getElementById(templateId);

  // Клонируем первый дочерний элемент шаблона вместе со всеми его потомками
  const clone = template.content.firstElementChild.cloneNode(true);

  // Находим все элементы с атрибутом data-name и создаем объект,
  // где ключами являются значения data-name, а значениями - сами элементы
  const elements = Array.from(clone.querySelectorAll("[data-name]")).reduce(
    (acc, el) => {
      acc[el.dataset.name] = el;
      return acc;
    },
    {},
  );

  // Возвращаем объект с контейнером (клоном шаблона) и именованными элементами
  return {
    container: clone,
    elements: elements,
  };
}

/**
 * Преобразует объект FormData в обычный JavaScript-объект (только одиночные значения)
 *
 * @param {FormData} formData - Объект FormData для преобразования
 * @returns {Object} - Обычный объект со значениями формы
 *
 * Подробнее: FormData — это специальный интерфейс для работы с данными форм,
 * но часто удобнее работать с обычными JavaScript-объектами. Эта функция
 * преобразует FormData в простой объект, где ключи соответствуют именам полей формы,
 * а значения - введенным данным. Обратите внимание, что эта функция обрабатывает
 * только одиночные значения и не поддерживает множественные значения для одного ключа
 * (как в случае с multiple select или checkbox).
 */
export function processFormData(formData) {
  // Преобразуем entries() в массив пар [ключ, значение] и создаем объект
  return Array.from(formData.entries()).reduce((result, [key, value]) => {
    result[key] = value;
    return result;
  }, {});
}

/**
 * Преобразует коллекцию в объект-индекс по уникальному полю
 *
 * @param {Array} arr - Исходная коллекция объектов
 * @param {string} field - Должно быть уникальным!
 * @param {(Object) => any} val - Функция преобразования значений
 * @returns {Object} - Объект, индексированный по указанному полю
 *
 * Подробнее: Эта функция полезна для создания справочников или поисковых индексов.
 * Она преобразует массив объектов в объект, где ключами выступают значения
 * указанного поля каждого объекта, а значениями — результат применения
 * функции-преобразователя к исходному объекту. Это позволяет быстро находить
 * объекты по их уникальному идентификатору с вычислительной сложностью O(1)
 * вместо O(n) при переборе массива.
 */
export const makeIndex = (arr, field, val) =>
  arr.reduce(
    (acc, cur) => ({
      ...acc, // Копируем все уже накопленные значения
      [cur[field]]: val(cur), // Добавляем новое поле с именем из cur[field] и значением из val(cur)
    }),
    {},
  );

/**
 * Возвращает массив номеров страниц, центрированный вокруг текущей страницы
 *
 * @param {number} currentPage - Текущая активная страница
 * @param {number} maxPage - Максимальный доступный номер страницы
 * @param {number} limit - Максимальное количество отображаемых страниц
 * @returns {number[]} Массив номеров страниц
 *
 * Подробнее: Эта функция создает массив номеров страниц для пагинации,
 * центрированный вокруг текущей страницы. Она особенно полезна для
 * пользовательских интерфейсов, где нужно отображать ограниченное количество
 * номеров страниц (например, "1 2 3 ... 10" вместо "1 2 3 4 5 6 7 8 9 10").
 *
 * Алгоритм гарантирует, что:
 * 1. Текущая страница находится примерно в центре отображаемого диапазона
 * 2. Количество отображаемых страниц не превышает указанный лимит
 * 3. Диапазон корректируется у краев (начало и конец списка страниц)
 */
export function getPages(currentPage, maxPage, limit) {
  // Проверяем, что входные данные являются корректными числами
  currentPage = Math.max(1, Math.min(maxPage, currentPage)); // currentPage должен быть от 1 до maxPage
  limit = Math.min(maxPage, limit); // limit не должен превышать maxPage

  // Вычисляем диапазон страниц для отображения
  let start = Math.max(1, currentPage - Math.floor(limit / 2)); // Начинаем с currentPage минус половина лимита
  let end = start + limit - 1; // Заканчиваем через limit страниц после start

  // Корректируем, если мы близко к концу
  if (end > maxPage) {
    end = maxPage; // Не выходим за пределы максимальной страницы
    start = Math.max(1, end - limit + 1); // Пересчитываем начало
  }

  // Создаем массив номеров страниц
  const pages = [];
  for (let i = start; i <= end; i++) {
    pages.push(i);
  }

  return pages;
}
